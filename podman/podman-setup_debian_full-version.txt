

podman is a tool for managing (Kubernetes) pods, containers and container images, available from https://github.com/containers/libpod

To install podman from scratch in Debian/ubuntu we need to have the below requirement met

golang >= 1.8 (stretch+)
docker-runc
conmon
CNI networking
ostree (Packaged)
libapparmor-dev

1) $ apt -y update

2) $ apt -y install \
  vim \
  curl \
  gcc \
  make \
  cmake \
  git \
  btrfs-progs \
  golang-go \
  go-md2man \
  iptables \
  libassuan-dev \
  libc6-dev \
  libdevmapper-dev \
  libglib2.0-dev \
  libgpgme-dev \
  libgpg-error-dev \
  libostree-dev \
  libprotobuf-dev \
  libprotobuf-c-dev \
  libseccomp-dev \
  libselinux1-dev \
  libsystemd-dev \
  pkg-config \
  runc \
  uidmap \
  libapparmor-dev

3) check the runc version

root@test:~# runc -version
runc version spec: 1.0.1-dev

4) install GOLANG

mkdir ~/go
nano ~/.bashrc

export GOPATH=~/go
export PATH=$GOPATH/bin:$PATH:/$HOME/.local/bin/
source ~/.bashrc

mkdir -p ~/.config/systemd/user/

git clone https://go.googlesource.com/go $GOPATH
cd $GOPATH
git checkout tags/go1.10.8  # optional
cd src
./all.bash

5) conmon is used to monitor OCI Runtimes. To build from source, use the following:

cd ~
git clone https://github.com/containers/conmon
cd conmon
export GOCACHE="$(mktemp -d)"
make
sudo make podman
sudo cp /usr/local/libexec/podman/conmon  /usr/local/bin/

6) Configure CNI

A basic network configuration can be achieved with:

sudo mkdir -p /etc/cni/net.d
curl -qsSL https://raw.githubusercontent.com/containers/libpod/master/cni/87-podman-bridge.conflist | sudo tee /etc/cni/net.d/87-podman-bridge.conf

7) Install CNI Plugins

cd ~
git clone https://github.com/containernetworking/plugins.git $GOPATH/src/github.com/containernetworking/plugins
cd $GOPATH/src/github.com/containernetworking/plugins
./build_linux.sh
sudo mkdir -p /usr/libexec/cni
sudo cp bin/* /usr/libexec/cni

Others Directories where the CNI plugin binaries may be located

cni_plugin_dir = [
"/usr/libexec/cni",
"/usr/lib/cni",
"/usr/local/lib/cni",
"/opt/cni/bin"
]

8) Add Podman configuration registries,policy

cd ~
sudo mkdir -p /etc/containers
sudo curl https://raw.githubusercontent.com/projectatomic/registries/master/registries.fedora -o /etc/containers/registries.conf
sudo curl https://raw.githubusercontent.com/containers/skopeo/master/default-policy.json -o /etc/containers/policy.json

9) Install PODMAN

PODMAN:

sudo su

echo 'deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_10/ /' > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/Debian_10/Release.key -O- | apt-key add -

echo 'deb http://deb.debian.org/debian buster-backports main' >> /etc/apt/sources.list
echo 'deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_10/ /' > /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_10/Release.key | sudo apt-key add -
exit
sudo apt-get update
sudo apt-get -y -t buster-backports install libseccomp2
sudo apt install podman buildah -y

or

cd ~
git clone https://github.com/containers/libpod/ $GOPATH/src/github.com/containers/libpod
cd $GOPATH/src/github.com/containers/libpod
make BUILDTAGS="selinux seccomp"
sudo make install PREFIX=/usr

PODMAN-COMPOSE:

sudo apt install python3-pip

pip3 install podman-compose

or

pip3 install https://github.com/containers/podman-compose/archive/devel.tar.gz

or

curl -o /usr/local/bin/podman-compose https://raw.githubusercontent.com/containers/podman-compose/devel/podman_compose.py
chmod +x /usr/local/bin/podman-compose

FEDORA:

sudo dnf install podman-compose

COCKPIT-PODMAN:

echo 'deb http://ftp.de.debian.org/debian sid main' > /etc/apt/sources.list.d/ftp.de.debian.org.list
echo 'deb http://ftp.de.debian.org/debian buster-backports main' >> /etc/apt/sources.list.d/ftp.de.debian.org.list

# sudo apt install cockpit-podman cockpit-bridge

sudo apt install cockpit -y

sudo usermod -aG adm,users USERNAME

# sudo systemctl enable cockpit
# sudo systemctl start cockpit
sudo systemctl enable --now cockpit.socket
sudo systemctl start cockpit.socket

# echo 'deb http://ftp.de.debian.org/debian sid main' > /etc/apt/sources.list.d/ftp.de.debian.org.list
sudo apt install firewalld -y
sudo systemctl enable firewalld.service
sudo systemctl start firewalld.service

sudo firewall-cmd --add-service=cockpit
sudo firewall-cmd --add-service=cockpit --permanent

sudo apt install cockpit-podman -y
sudo systemctl restart cockpit
sudo systemctl restart cockpit.socket


If you want to replace Docker, one can install podman-docker to mimic the docker binary along with man pages.
Если вы хотите заменить Docker, можно установить podman-docker, чтобы имитировать двоичный файл docker вместе со многими страницами.

# # echo 'deb http://ftp.de.debian.org/debian sid main' > /etc/apt/sources.list.d/ftp.de.debian.org.list
sudo apt install podman-docker -y




DNSNAME.

If you are using AppArmor you might end up with problems when creating container using a bridge network with the dnsname plugin enabled:
Если вы используете AppArmor, у вас могут возникнуть проблемы при создании контейнера с использованием мостовой сети с включенным подключаемым модулем dns-имен:


This can be solved by adding the following lines to:
$ sudo nano /etc/apparmor.d/local/usr.sbin.dnsmasq

owner /run/user/[0-9]*/containers/cni/dnsname/*/dnsmasq.conf r,
owner /run/user/[0-9]*/containers/cni/dnsname/*/addnhosts r,
owner /run/user/[0-9]*/containers/cni/dnsname/*/pidfile rw,

or

/run/containers/cni/dnsname/*/dnsmasq.conf r,
/run/containers/cni/dnsname/*/addnhosts r,
/run/containers/cni/dnsname/*/pidfile rw,

$ sudo apparmor_parser -R /etc/apparmor.d/usr.sbin.dnsmasq
# sudo apparmor_parser /etc/apparmor.d/usr.sbin.dnsmasq
# sudo apparmor_parser -r /etc/apparmor.d/usr.sbin.dnsmasq

To get hostname resolution between containers running install podman-dnsname.
Чтобы получить разрешение имени хоста между запущенными контейнерами, установите podman-dnsname.

$ sudo apt install podman-dnsname -y

OR Build and install.
ИЛИ Собрать и установить.

$ git clone https://github.com/containers/dnsname.git
$ cd dnsname
$ make install PREFIX=/usr

Configure a CNI network for Podman

$ podman network create foobar
$ nano /home/user/.config/cni/net.d/foobar.conflist
or
$ sudo nano /etc/cni/net.d/foobar.conflist

{
  "cniVersion": "0.4.0",
  "name": "foobar",
  "plugins": [
     ...
     {
        "type": "dnsname",
        "domainName": "dns.podman",
        "capabilities": {
           "aliases": true
        }
     }
  ]
}



10) 

$ sudo usermod --add-subuids 10000-75535 USERNAME
$ sudo usermod --add-subgids 10000-75535 USERNAME

$ sudo nano /etc/sysctl.conf

kernel.unprivileged_userns_clone=1

$ sudo sysctl -p

$ sudo loginctl enable-linger USERNAME

Docker Compose.

$ sudo ln -sf /var/run/podman.sock /var/run/docker.sock
$ sudo systemctl enable --now podman.socket
$ systemctl --user enable --now podman.socket

The administrator of a workstation can allow users to expose services on ports numbered lower than 1024, 
but they should understand the security implications. 
A regular user could, for example, run a web server on the official port 80 and make external users believe 
that it was configured by the administrator. This is acceptable on a workstation for testing, 
but might not be a good idea on a network-accessible development server, and definitely should not be done on production servers. 
To allow users to bind to ports down to port 80 run the following command.

Администратор рабочей станции может разрешить пользователям предоставлять услуги на портах с номерами ниже 1024, 
но они должны понимать последствия для безопасности. Обычный пользователь может, например, 
запустить веб-сервер на официальном порту 80 и заставить внешних пользователей поверить, 
что он был настроен администратором. Это приемлемо на рабочей станции для тестирования, 
но может оказаться не очень хорошей идеей на сервере разработки, доступном к сети, 
и определенно не должно выполняться на производственных серверах. 
Чтобы разрешить пользователям привязываться к портам вплоть до порта 80, выполните следующую команду.

$ nano /etc/sysctl.conf
net.ipv4.ip_unprivileged_port_start=80


11) Test Podman

podman help

Запуск и проверка cockpit

sudo systemctl status cockpit

Browser
https://ip:9090
The SSL certificate to self signed is CORRECT.

DNSNAME Test

$ sudo podman run -dt --name web --network foobar quay.io/libpod/alpine_nginx:latest
5139d65d22135e9ecab511559d863754550894a32285befd94dab231017048c2

$ sudo podman run -it --name client --network foobar quay.io/libpod/alpine_nginx:latest curl http://web.dns.podman/ 
podman rulez








